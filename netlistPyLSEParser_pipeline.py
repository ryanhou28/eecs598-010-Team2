import ply.lex as lex
import ply.yacc as yacc
import random
import argparse
import os
import sys

# Usage:
# python netlistPyLSEParser_pipeline.py <verilog_netlist_file> [-o <output_file>]
#   Example:
#   python netlistPyLSEParser_pipeline.py synth_scripts/comb85/c6288_N.v
#   python netlistPyLSEParser_pipeline.py synth_scripts/comb85/c6288_N.v -o my_c6288_N.py
# If -o is not specified, the output file will be named <verilog_netlist_file>_PyLSE.py in the same directory as the script
# For help:
# python netlistPyLSEParser_pipeline.py -h

# Description:
# The script takes a Verilog netlist file generated from the given synthesis scripts. Currently, this script only supports the format of _MAP.v netlists generated by the synthesis script.
# This script parses the netlist to generate the module in PyLSE, while giving it some initial inputs for simulation.
# The inputs of the generated modules will be dual-railed, while the outputs will be single-rail.
# *Note that the some outputs generated by this module can be the inverted outputs of the original output, depending on the polarity that the synthesis script assigned to it.
#       i.e. the outputs that were connected to inverters in the original netlist will be inverted in the generated netlist.
# The clock period T of the generated simulation can be tuned as the parameter time_period in this script.

# ------------------------ LEXER ------------------------

# Dictionary of reserved words
reserved = {
    'module' : 'MODULE',
    'input'  : 'INPUT',
    'output' : 'OUTPUT',
    'wire'   : 'WIRE',
    'buf1'    : 'BUF',
    'not1'    : 'NOT',
    'and1'    : 'AND',
    'or1'     : 'OR',
    'endmodule' : 'ENDMODULE',
    'always' : 'ALWAYS',
    'begin' : 'BEGIN',
    'initial' : 'INITIAL',
    'end' : 'END',
    'reg' : 'REG'
}

# Define tokens
tokens = [
    'ID',
    'NUMBER',
    'LPAREN',
    'RPAREN',
    'COMMA',
    'SEMI',
    'COLON',
    'NB_ASSIGN', # Verilog non-blocking assignment: <=
    'APO', # apostrophe
    'F_SLASH',
    'DOT',
    'AT',
    'BINARY_ID',
    'HEX_ID',
    'DECIMAL_ID'
]

tokens += list(reserved.values())

# Define a dictionary of tokens
t_NUMBER  = r'\d+'
t_LPAREN  = r'\('
t_RPAREN  = r'\)'
t_COMMA   = r','
t_SEMI    = r';'
t_COLON   = r':'
t_NB_ASSIGN = r'<='
# Apostrophe
t_APO = r'\''
t_F_SLASH = r'/'
t_DOT = r'\.'
t_AT = r'@'

# Define regular expressions for binary, hexadecimal, and decimal identifiers. TODO: move this to the top
t_BINARY_ID = r'\'b'
t_HEX_ID = r'\'h'
t_DECIMAL_ID = r'\'d'

# Define a rule so we can track line numbers
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

# Token rule with some action code, checking for reserved words
def t_ID(t):
    # ID can be alphabetical characters, numbers, or the character \ and | 
    r'[a-zA-Z\\_][a-zA-Z0-9_|\\]*'
    t.type = reserved.get(t.value, 'ID')    # Check for reserved words
    return t

# Define a rule to ignore whitespace
t_ignore = ' \t'

# Define a token for single-line comments
def t_COMMENT(t):
    r'\/\/.*'
    pass # Ignore comments

# Define a token for multi-line comments
def t_COMMENT_MULTI(t):
    r'\/\*[\s\S]*?\*\/'
    pass # Ignore comments


# Define error handling rule
def t_error(t):
    print("Illegal character '%s'" % t.value[0])
    t.lexer.skip(1)

# ------------------------ END LEXER ------------------------

# ------------------------ PARSER ------------------------

# Define the grammar

# Module declaration
def p_module(p):
    'module_decl : MODULE ID ports SEMI module_items ENDMODULE'
    p[0] = ('module_decl', p[2], p[3], p[5])

def p_ports(p):
    '''ports : LPAREN port_list RPAREN
             | LPAREN RPAREN'''
    if len(p) == 4:
        p[0] = p[2]
    else:
        p[0] = []

def p_port_list(p):
    '''port_list : port_list COMMA port
                 | port'''
    if len(p) == 4:
        p[1].append(p[3])
        p[0] = p[1]
    else:
        p[0] = [p[1]]

def p_port(p):
    '''port : INPUT ID
            | OUTPUT ID
            | WIRE ID
            | REG ID
            | ID'''
    if len(p) == 3:
        # For cases where there are two elements: INPUT/OUTPUT/WIRE and ID
        p[0] = ('port', p[1], p[2])
    elif len(p) == 2:
        # For the case where there's only an ID
        p[0] = ('port', 'ID', p[1])


# def p_range(p):
#     'range : LPAREN NUMBER COLON NUMBER RPAREN'
#     p[0] = (p[2], p[4])  # Return a tuple representing the 

def p_module_items(p):
    '''module_items : module_items module_item
                    | module_item'''
    if len(p) == 3:
        p[0] = p[1] + [p[2]]
    else:
        p[0] = [p[1]]

# Rule for handling gate primitives instantiation
def p_gate_instantiation(p):
    '''gate_instantiation : buf_instantiation
                          | not_instantiation
                          | or_instantiation
                          | and_instantiation'''
    p[0] = p[1]

def p_buf_instantiation(p):
    'buf_instantiation : BUF ID LPAREN input_terminal COMMA output_terminal RPAREN SEMI'
    p[0] = ('buf', p[4], p[6])

def p_not_instantiation(p):
    'not_instantiation : NOT ID LPAREN input_terminal COMMA output_terminal RPAREN SEMI'
    p[0] = ('not', p[4], p[6])

def p_or_instantiation(p):
    'or_instantiation : OR ID LPAREN input_terminal COMMA input_terminal COMMA output_terminal RPAREN SEMI'
    p[0] = ('or', p[4], p[6], p[8])

def p_and_instantiation(p):
    'and_instantiation : AND ID LPAREN input_terminal COMMA input_terminal COMMA output_terminal RPAREN SEMI'
    p[0] = ('and', p[4], p[6], p[8])

# Define rules for output_terminal and input_terminal which are basically identifiers (IDs)
def p_output_terminal(p):
    '''output_terminal : ID
                       | DOT ID LPAREN ID RPAREN'''
    if (len(p) == 2):
        p[0] = p[1]
    else:
        p[0] = p[4]

# GLOBAL VAR FOR TRACKING IF AN INPUT NEEDS A SPLITTER
input_terminal_dict = {}
input_terminal_count_dict = {} # counts the number of terminals while we assign the splitter index to it in code generation, initialize to 0 if it needs splitting
dro_c_in_out_dict = {} # keeps track of the input and output terminals of DRO_Cs. Key: value wire name, Value: Register wiren ame
def p_input_terminal(p):
    '''input_terminal : ID
                      | DOT ID LPAREN ID RPAREN'''
    if (len(p) == 2):
        p[0] = p[1]
    else:
        p[0] = p[4]
    
    global input_terminal_dict
    # If the input terminal is not in the dictionary, add it
    if p[0] not in input_terminal_dict:
        input_terminal_dict[p[0]] = 1
    else:
        # Increment the number of times this wire appears as an input terminal
        input_terminal_dict[p[0]] += 1
        # Initialize the assigned count for this input terminal to 0
        input_terminal_count_dict[p[0]] = 0

# Input list for gates like OR and AND that can have multiple inputs
def p_input_list(p):
    '''input_list : input_list COMMA input_terminal
                  | input_terminal'''
    if len(p) == 4:  # Multiple inputs
        p[0] = p[1] + [p[3]]
    else:  # Single input
        p[0] = [p[1]]

def p_input_decl(p):
    '''input_decl : INPUT ID SEMI
                  | INPUT ID_list SEMI'''
    p[0] = ('input', p[2])

def p_output_decl(p):
    '''output_decl : OUTPUT ID SEMI
                   | OUTPUT ID_list SEMI'''
    p[0] = ('output', p[2])

def p_ID_list(p):
    '''ID_list : ID_list COMMA ID
               | ID'''
    if len(p) == 4:
        p[1].append(p[3])
        p[0] = p[1]
    else:
        p[0] = [p[1]]

def p_wire_decl(p):
    '''wire_decl : WIRE ID SEMI
                 | WIRE ID_list SEMI'''
    p[0] = ('wires', p[2])

def p_reg_decl(p):
    '''reg_decl : REG ID SEMI
                | REG ID_list SEMI'''
    p[0] = ('reg', p[2])

def p_module_item(p):
    '''module_item : wire_decl
                   | gate_instantiation
                   | input_decl
                   | output_decl
                   | reg_decl
                   | always_at
                   | initial_block'''
    p[0] = p[1]

def p_always_at(p):
    ''' always_at : ALWAYS AT LPAREN ID ID RPAREN BEGIN reg_assign_list END'''
    p[0] = ('always_at', p[4], p[5], p[8])

def p_reg_assign(p):
    ''' reg_assign : ID NB_ASSIGN ID SEMI'''
    p[0] = ('reg_assign', p[1], p[3])
    global dro_c_in_out_dict

    dro_c_in_out_dict[p[3]] = p[1]

def p_reg_assign_list(p):
    ''' reg_assign_list : reg_assign_list reg_assign
                        | reg_assign'''
    if len(p) == 3:
        p[1].append(p[2])
        p[0] = p[1]
    else:
        p[0] = [p[1]]

def p_const_value(p):
    ''' const_value : NUMBER
                    | NUMBER BINARY_ID NUMBER
                    | NUMBER HEX_ID NUMBER
                    | NUMBER DECIMAL_ID NUMBER'''
    if len(p) == 2:
        p[0] = p[1]
    else:
        if p[2] == '\'b':
            base = 2
        elif p[2] == '\'h':
            base = 16
        elif p[2] == '\'d':
            base = 10
        else:
            # Print the line number of this and the value of p
            print(p[2])
            print("Invalid constant representation type at", p.lineno(3), ", base:", p[2], ", number:", p[3])
            raise ValueError("Invalid constant representation type")
        value = int(p[3], base)
        p[0] = (value)

def p_reg_assign_const_list(p):
    ''' reg_assign_const_list : reg_assign_const_list reg_assign_const
                              | reg_assign_const'''
    if len(p) == 3:
        p[1].append(p[2])
        p[0] = p[1]
    else:
        p[0] = [p[1]]

def p_reg_assign_const(p):
    ''' reg_assign_const : ID NB_ASSIGN const_value SEMI'''
    p[0] = ('reg_assign_const', p[1], p[3])

def p_initial_block(p):
    ''' initial_block : INITIAL BEGIN reg_assign_const_list END'''
    p[0] = ('initial_block', p[3])

# Error rule for syntax errors
def p_error(p):
    if p:
        print("Syntax error at line %d, column %d: '%s'" % (p.lineno, p.lexpos, p.value))
    else:
        print("Syntax error: unexpected end of input")

# ------------------------ END PARSER ------------------------

# Print the AST
def print_ast(ast, level=0):
    indent = "  " * level
    if isinstance(ast, tuple):
        print(f"{indent}{ast[0]}")
        for item in ast[1:]:
            print_ast(item, level + 1)
    elif isinstance(ast, list):
        for item in ast:
            print_ast(item, level)
    elif isinstance(ast, dict):
        for key, value in ast.items():
            print(f"{indent}{key}")
            print_ast(value, level + 1)
    else:  # for leaves of the AST
        print(f"{indent}{ast}")


# ------------------------ GENERATE CODE ------------------------

# Generate the PyLSE code
def generate_code(node):
    node_type = node[0]
    if node_type == 'module_decl':
        return generate_module(node)
    elif node_type == 'ports':
        return generate_ports(node)
    elif node_type == 'port_list':
        return generate_port_list(node)
    elif node_type == 'port':
        return generate_port(node)
    elif node_type == 'module_items':
        return generate_module_items(node)
    elif node_type == 'gate_instantiation':
        return generate_gate_instantiation(node)
    elif node_type == 'buf':
        return generate_buf(node)
    elif node_type == 'not':
        return generate_not(node)
    elif node_type == 'or':
        return generate_or(node)
    elif node_type == 'and':
        return generate_and(node)
    elif node_type == 'output_terminal':
        return generate_output_terminal(node)
    elif node_type == 'input_terminal':
        return generate_input_terminal(node)
    elif node_type == 'input':
        return generate_input(node)
    elif node_type == 'output':
        return generate_output(node)
    elif node_type == 'wires':
        return generate_wires(node)
    elif node_type == 'reg':
        return generate_reg(node)
    elif node_type == 'module_item':
        return generate_module_item(node)
    elif node_type == 'always_at':
        return generate_always_at(node)
    elif node_type == 'reg_assign':
        return generate_reg_assign(node)
    elif node_type == 'reg_assign_const':
        return generate_reg_assign_const(node)
    elif node_type == 'initial_block':
        return generate_initial_block(node)
    else:
        print("*** ERROR ***")
        print("Unknown node type:", node_type)
        print(node)
        raise Exception(f"Unknown node type: {node_type}")


# Some global variables to keep track of important info about the module
module_name = []
module_ports = []
input_ports = []
output_ports = []
reg_list = []
flipped_DRO_C_dict = {}
# Used for counting how many times a wire needs to be split
clock_split_count = 0


all_wires_code = ''

def generate_module(node):
    # node is a tuple like ('module_decl', module_name, ports, items)
    print("Generating code for module")
    name = node[1]
    ports = node[2]
    items = node[3]
    # Generate helper codee that defines the xSFQ gates
    helper_code = f'''
    # Define helpers to ensure same delay numbers (currently the same as PyLSE example)
    def jtl(*args):
        return pylse.jtl(*args, firing_delay=5.7)

    def fa(x, y):
        """ First-arrival cell based on an inverted C-element.
            Inputs buffered with JTL for better flux transmission.
        """
        return pylse.c_inv(jtl(x), jtl(y), firing_delay=9.0)

    def la(x, y):
        """ Last-arrival cell based on a C-element.
            Inputs buffered with JTL for better flux transmission.
        """
        return pylse.c(jtl(x), jtl(y), firing_delay=8.0)

    def s(x):
        return pylse.s(x, firing_delay=4.3)

    def dro(*args):
        return pylse.dro(*args, firing_delay=5.1)
        
    def dro_c(*args):
        return pylse.dro_c(*args, firing_delay=5.1)
        
    def dro_c_inv(*args):
        return my_dro_c_inv(*args, firing_delay=5.1)\n'''

    # Global variables
    global clock_split_count
    global all_wires_code

    module_name.append(name)
    
    # ports_code = ', '.join(generate_code(port) for port in ports)

    items_code = ''
    for item in items:
        item_code = generate_code(item)
        if item_code != '':
            items_code += f'    {item_code}\n'

    # items_code = '\n    '.join(generate_code(item) for item in items)

    # Remove double newlines for better formatting
    items_code = items_code.replace('\n    \n', '')

    input_ports_code = ', '.join(f'{input_port}_p, {input_port}_n' for input_port in input_ports)
    output_ports_code = ', '.join(f'{output_port}' for output_port in output_ports)

    # Add the splitter code
    # Go through every wire in the splitter dictionary
    input_splitter_code = ''
    for wire_name, num_splitters in input_terminal_dict.items():
        if num_splitters == 1:
            # This wire doesn't need to be split
            continue

        # Check if this wire is in the port list or in the reg list
        if wire_name in input_ports or wire_name in reg_list:
            # This wire is an input to the module
            # Don't split it
            continue

        input_splitter_code += f'    {wire_name}_spl_ = pylse.split({wire_name}, n={num_splitters}, firing_delay=4.3)\n'

    # Insert splitters for the clock signal
    input_splitter_code += f'    clks = pylse.split(clk, n={clock_split_count}, firing_delay=4.3)\n'

    return f'def {name}({input_ports_code}, clk):\n{helper_code}\n{all_wires_code}\n{input_splitter_code}\n{items_code}\n\n    return {output_ports_code}\n'

def generate_ports(node):
    # node is a tuple like ('ports', port_list)
    print("Generating code for ports")
    port_list = node[1]
    return ', '.join(generate_code(port) for port in port_list)

def generate_port_list(node):
    # node is a tuple like ('port_list', port_list)
    print("Generating code for port list")
    port_list = node[1]
    return ', '.join(generate_code(port) for port in port_list)

def generate_port(node):
    # node is a tuple like ('port', port_type, port_name)
    print("Generating code for port")
    port_type = node[1]
    port_name = node[2]
    # Create dual-railed ports
    port_p = f'{port_name}_p'
    port_n = f'{port_name}_n'
    # Add the port to the list of ports to the module
    module_ports.append(port_name)

    return f'{port_p}, {port_n}'

def generate_module_items(node):
    # node is a tuple like ('module_items', module_items)
    print("Generating code for module items")
    module_items = node[1]
    
    return '\n    '.join(generate_code(item) for item in module_items)

def generate_gate_instantiation(node):
    # node is a tuple like ('gate_instantiation', gate_instantiation)
    print("Generating code for gate instantiation")
    gate_instantiation = node[1]
    return generate_code(gate_instantiation)


def input_terminal_add_splitter(input_terminal):
    # Check if this wire needs to be split
    if input_terminal in input_terminal_count_dict:
        
        # Check if this terminal is in the port list or in the reg list
        if input_terminal in input_ports or input_terminal in reg_list:
            # This wire is an input to the module
            # Don't split it
            return input_terminal

        curr_input_terminal_count = input_terminal_count_dict[input_terminal]
        # Increment the used splitter count for this wire
        input_terminal_count_dict[input_terminal] += 1
        # Generate the splitted input terminal name
        input_terminal += '_spl_[' + str(curr_input_terminal_count) + ']'
    
    return input_terminal

def generate_buf(node):
    # node is a tuple like ('buf', input_terminal, output_terminal)
    print("Generating code for buf")
    output_terminal = node[2]
    input_terminal = node[1]

    input_terminal = input_terminal_add_splitter(input_terminal)

    if input_terminal in input_ports:
        # Connect the positive input to the port
        return f'{output_terminal} <<= {input_terminal}_p'
    elif output_terminal in output_ports:
        # If the output terminal is one of the module's outputs, connect the input_terminal to the output
        return f'{output_terminal} = {input_terminal}'
    elif input_terminal in reg_list:
        # If the input terminal is a register, we use the positive output of the DRO_C
        return f'{output_terminal} <<= {input_terminal}_p'
    elif 'spl' in output_terminal:
        # This is a splitter
        # Skip splitting and deal with it with the whole module
        # return f'{output_terminal}1, {output_terminal}2 = s({input_terminal})'
        return f''
    else:
        # Straight connection

        # global clock_split_count

        # code = f'{output_terminal} = dro({input_terminal}, clks[{clock_split_count}])'

        # clock_split_count += 1

        # return code

        return f'{output_terminal} <<= {input_terminal}' # OLD

def generate_not(node):
    # node is a tuple like ('not', input_terminal, output_terminal)
    print("Generating code for not")
    output_terminal = node[2]
    input_terminal = node[1]

    input_terminal = input_terminal_add_splitter(input_terminal)

    # Check if this output terminal is connected to the input of a DRO_C
    # If it is, we need to tell DRO_C that its input is flipped
    global dro_c_in_out_dict
    if output_terminal in dro_c_in_out_dict:
        flipped_DRO_C_dict[output_terminal] = True
    # Check that the input terminal is not one of the inputs to the module
    #   Since we already have dual-railed inputs, we don't need this NOT gate
    if input_terminal in input_ports:
        # Connect the negative input port to this output
        return f'{output_terminal} <<= {input_terminal}_n'
    elif output_terminal in output_ports:
        # If the output terminal is one of the outputs to the module, we don't need this NOT gate
        #   The true output is just the input to the NOT gate
        # return f'{output_terminal} = {input_terminal}'
        # return f'{output_terminal} = ' + generate_input_terminal(input_terminal)
        return f'{output_terminal} = {input_terminal}'
    elif input_terminal in reg_list:
        # If the input terminal is a register, we use the complementary output of the DRO_C
        return f'{output_terminal} <<= {input_terminal}_n'
    elif output_terminal in dro_c_in_out_dict:
        # We're going to flip the output of this DRO_C, which is already dealt with earlier in this function
        return f'{output_terminal} <<= {input_terminal}'
    else:
        # Not gate in xSFQ is just connecting the dual-railed terminals
        # Raise exception since this is an unsupported format
        raise Exception(f"Input terminal {input_terminal} to NOT gate does not conform to supported format")

def generate_or(node):
    # node is a tuple like ('or', input_terminal, input_terminal, output_terminal)
    print("Generating code for or")
    output_terminal = node[3]
    input_terminal1 = node[1]
    input_terminal2 = node[2]

    input_terminal1 = input_terminal_add_splitter(input_terminal1)
    input_terminal2 = input_terminal_add_splitter(input_terminal2)

    # OR gate in xSFQ is a first-arrival cell
    return f'{output_terminal} <<= fa({input_terminal1}, {input_terminal2})'

def generate_and(node):
    # node is a tuple like ('and', input_terminal, input_terminal, output_terminal)
    print("Generating code for and")
    output_terminal = node[3]
    input_terminal1 = node[1]
    input_terminal2 = node[2]

    input_terminal1 = input_terminal_add_splitter(input_terminal1)
    input_terminal2 = input_terminal_add_splitter(input_terminal2)

    return f'{output_terminal} <<= la({input_terminal1}, {input_terminal2})'

def generate_output_terminal(node):
    # node is a single output terminal
    # NOT USED CURRENTLY
    print("Generating code for output terminal")
    output_terminal = node
    return output_terminal

def generate_input_terminal(node):
    # node is a single input terminal
    print("Generating code for input terminal")
    input_terminal = node
    # Check if the input terminal is a splitter
    if 'spl' in input_terminal:
        # This is a splitter
        # Find the name of the input terminal, ie the name before '_spl_'
        input_name_split = input_terminal.split('_spl')
        var_name = input_name_split[0]
        # If the variable name is not in the splitter count dictionary, add it
        if var_name not in splitter_dict:
            splitter_dict[var_name] = 1
            return f'{var_name}_spl_[0]'
        else:
            splitter_dict[var_name] += 1
            return f'{var_name}_spl_[{splitter_dict[var_name] - 1}]'
    return input_terminal

def generate_input(node):
    # node is a tuple like ('input', input_name)
    print("Generating code for input")
    input_name = node[1]
    global input_ports

    for input_i in input_name:
        # Add the input to the list of inputs to the module
        input_ports.append(input_i)
        # Add the input to the list of ports to the module
        module_ports.append(input_i)
    # return f'{input_name} = Input()'
    return f''

def generate_output(node):
    # node is a tuple like ('output', output_name)
    print("Generating code for output")
    output_name = node[1]
    for output_i in output_name:
        # Add the output to the list of outputs to the module
        output_ports.append(output_i)
        # Add the output to the list of ports to the module
        module_ports.append(output_i)
    # return f'{output_name} = Output()'
    return f''


def generate_wires(node):
    # node is a tuple like ('wires', wire_name)
    print("Generating code for wires")
    wires = node[1]
    wire_code = '\n'

    global all_wires_code

    for wire in wires:
        wire_code += f'    {wire} = pylse.Wire()\n'
    
    all_wires_code += wire_code
    # return wire_code
    return f''

def generate_module_item(node):
    # node is a tuple like ('module_item', module_item)
    print("Generating code for module item")
    module_item = node[1]
    return generate_code(module_item)

def generate_reg(node):
    # node is a tuple like ('reg', reg_name)
    print("Generating code for reg")
    reg_name = node[1]
    # return f'{reg_name} = Reg()'

    reg_code = '\n'
    global reg_list
    for reg_i in reg_name:
        reg_list.append(reg_i)
        reg_code += f'    {reg_i}_p = pylse.Wire()\n'
        reg_code += f'    {reg_i}_n = pylse.Wire()\n'
    
    return reg_code

def generate_always_at(node):
    # node is a tuple like ('always_at', posedge/negedge, clock, reg_assign_list)
    print("Generating code for always_at")
    edge = node[1]
    clock = node[2]
    reg_assign_list = node[3]
    # return f'always_at({clock}, {reset}, {reg_assign_list})'

    code =  '\n    '.join(generate_reg_assign(reg_assign) for reg_assign in reg_assign_list)

    return code

def generate_reg_assign(node):
    # node is a tuple like ('reg_assign', reg_name, value)
    print("Generating code for reg assign")
    reg_name = node[1]
    value = node[2]
    # return f'{reg_name} = {value}'
    # Register assignment is translated to a DRO_C cell in PyLSE

    global clock_split_count
    global reg_list

    # If this DRO's input needs to be inverted, use the DRO_C_INV cell
    if value in flipped_DRO_C_dict:
        code = f'{reg_name} = dro_c_inv({value}, clks[{clock_split_count}])\n'
    else:
        code = f'{reg_name} = dro_c({value}, clks[{clock_split_count}])\n'
    code += f'    {reg_name}_p <<= {reg_name}[0]\n'
    code += f'    {reg_name}_n <<= {reg_name}[1]\n'

    clock_split_count += 1

    return code

def generate_reg_assign_const(node):
    # node is a tuple like ('reg_assign_const', reg_name, value)
    print("Generating code for reg assign const")
    reg_name = node[1]
    value = node[2]
    # return f'{reg_name} = {value}'
    return f''

def generate_initial_block(node):
    # node is a tuple like ('initial_block', reg_assign_const_list)
    print("Generating code for initial block")
    reg_assign_const_list = node[1]
    
    return ''.join(generate_reg_assign_const(reg_assign_const) for reg_assign_const in reg_assign_const_list)

def generate_pylse(result):
    # result is the AST
    print("Generating Python code")
    
    # First generate the imports needed
    code = '''import pylse
from collections import namedtuple
# Custom DRO_C with inverted input, and initialized to 0
class DRO_C_INV(pylse.SFQ):
    # Destructive readout C-element with inverted input
    # Essentially a DRO_C whose input is inverted
    _setup_time = 1.2
    _hold_time = 0.0

    name = 'DRO_C_INV'
    inputs = ['a', 'clk']
    outputs = ['q', 'qnot']
    transitions = [
        {'id': '0', 'source': 'idle',      'trigger': 'a',   'dest': 'idle'},
        {'id': '1', 'source': 'idle',      'trigger': 'clk', 'dest': 'a_absent',
         'transition_time': _hold_time,    'past_constraints': {'*': _setup_time},
         'firing': 'qnot'},
        {'id': '2', 'source': 'a_absent', 'trigger': 'a',   'dest': 'idle'},
        {'id': '3', 'source': 'a_absent', 'trigger': 'clk', 'dest': 'a_absent',
         'transition_time': _hold_time,    'past_constraints': {'*': _setup_time},
         'firing': 'q'},
    ]
    jjs = 13
    firing_delay = 5.1

def my_dro_c_inv(in0: pylse.Wire, clk: pylse.Wire, name_q=None, name_q_not=None, **overrides):
    # Create and connect a DRO_C
    # :param Wire in0: input wire
    # :param Wire clk: input wire traditionally corresponding to a clock
    # :param str name_q: Name to give the q output wire
    # :param str name_q_not: Name to give the q_not output wire
    # :param dict overrides: keyword arguments for overriding defaults of the element,
    #     such as: jjs, firing_delay, transition_time, error_transitions.
    # :return namedtuple: a tuple for accessing the outputs, .q and .q_not
    
    DRO_C_INV_out = namedtuple('DRO_C_INV_out', ['q', 'q_not'])
    q, q_not = pylse.Wire(name_q), pylse.Wire(name_q_not)
    pylse.working_circuit().add_node(DRO_C_INV(**overrides), [in0, clk], [q, q_not])
    return DRO_C_INV_out(q=q, q_not=q_not)\n\n\n'''

    code += generate_code(result)

    # Generate simulation code
    code += generate_pylse_sim()

    return code

def generate_pylse_sim():
    # Generate the simulation code for the module in PyLSE

    code = f'''
def inv(inp):
    if (inp == 1):
        return 0
    else:
        return 1\n\n'''

    # Generate test_single_input function
    code += f'def test_single_input('
    # Generate the input ports
    for input_port in input_ports:
        code += f'{input_port}, '
    # Remove the last comma and space
    code = code[:-2]
    code += f'):\n'
    code += f'    input_delay = 50\n'
    code += f'    print("Inputs:")\n'
    # print the name of the input ports
    code += f'    print("' + ' '.join(f'{input_port}' for input_port in input_ports) + f'")\n'
    code += f'    print(' + ', '.join(f'{input_port}' for input_port in input_ports) + f')\n'
    for input_port in input_ports:
        code += f'    {input_port}_p_t = inv({input_port})\n'
        code += f'    {input_port}_n_t = {input_port}\n'
    code += f'\n'
    for input_port in input_ports:
        code += f'    {input_port}_p = pylse.inp_at({input_port}_p_t*T + input_delay, name=\'{input_port}_p\')\n'
        code += f'    {input_port}_n = pylse.inp_at({input_port}_n_t*T + input_delay, name=\'{input_port}_n\')\n'
    code += f'\n'

    code += f'    return '
    for input_port in input_ports:
        code += f'{input_port}_p, {input_port}_n, '
    # Remove the last comma and space
    code = code[:-2]
    code += f'\n\n'

    # Generate check_events function
    code += f'def check_events(events, T):\n'
    code += f'    print("Output Events:")\n'
    code += f'    print("' + ' '.join(f'{output_port}' for output_port in output_ports) + f'")\n'
    code += f'    print('
    for output_port in output_ports:
        code += f'int(len(events[\'{output_port}\']) > 0 and events[\'{output_port}\'][0] < T), '
    # Remove the last comma and space
    code = code[:-2]
    code += f')\n\n'

    # Generate the main function
    code += f'if __name__ == "__main__":\n'
    code += f'    # Create clock signal\n'

    # Set the clock period for the simulation
    time_period = 100

    code += f'    T = {time_period}  # duration of a phase\n'
    code += "    clk = pylse.inp(start=T/2, period=T, n=4, name='clk')\n"

    # Generate the test inputs
    code += f'    '
    for input_port in input_ports:
        code += f'{input_port}_p, {input_port}_n, '

    # Remove the last comma and space
    code = code[:-2]
    code += f'= test_single_input('
    # Generate random inputs from 0 or 1 for each input
    for input_port in input_ports:
        code += f'{random.randint(0, 1)}, '
    # Remove the last comma and space
    code = code[:-2]
    code += f')\n\n'

    # Instantiate the module
    code += f'    # Instantiate the module\n'
    
    # For each output port, instantiate the output port
    code += f'    '
    for output_port in output_ports:
        code += f'{output_port}, '
    # Remove the last comma and space
    code = code[:-2]

    code += f'= {module_name[0]}('
    # For each input port, instantiate the input port
    for input_port in input_ports:
        code += f'{input_port}_p, {input_port}_n, '
    # Remove the last comma and space
    code = code[:-2]
    code += f', clk)\n\n'

    # Probe outputs
    code += f'    # Probe outputs\n'
    for output_port in output_ports:
        code += f'    pylse.inspect({output_port}, \'{output_port}\')\n'

    # Run the simulation
    code += f'''
    # Run simulation
    sim = pylse.Simulation()
    events = sim.simulate()
    sim.plot()


    # Print out the events
    check_events(events, T)
'''

    return code

# ------------------------ END GENERATE CODE ------------------------

# ------------------------ MAIN ------------------------

# Create argument parser
argparser = argparse.ArgumentParser(description='Parse a Verilog netlist and generate PyLSE code.')

# Add arguments
argparser.add_argument('verilog_file', type=str, help='The Verilog netlist file to parse.')
# optional argument for specifying where to store the output file
argparser.add_argument('-o', '--output', type=str, help='The directory to store the generated PyLSE file.')

# Parse the arguments
args = argparser.parse_args()

verilog_file = args.verilog_file

# Check if the input file exists
if not os.path.isfile(verilog_file):
    print(f"Error: The file {verilog_file} does not exist.")
    sys.exit(1)

outfile_name = args.output

# If the output file is not specified, store the generated file in the same directory as the input file
if outfile_name is None:
    outfile_name = verilog_file.split('/')[-1].split('.')[0] + '_PyLSE.py'
    # outfile_name = verilog_file.split('.')[0] + '_PyLSE.py' # This saves to the same directory as the input file

# Build the lexer
lexer = lex.lex()

# Build the parser
parser = yacc.yacc()

with open(verilog_file, 'r') as file:
    verilog_code = file.read()

# Error checking if file can't be opened
if verilog_code == '':
    print(f"Error: Could not open file {verilog_file}")
    exit()

# Format the code to replace [ and ] characters with _ characters
verilog_code = verilog_code.replace('[', '_').replace(']', '_')

# Alsy replace all instances of \ and | with _ characters
verilog_code = verilog_code.replace('\\', '_').replace('|', '_')

# Parse the input Verilog code
result = parser.parse(verilog_code, lexer=lexer)

# Now result contains the AST, we can print it
print_ast(result)

# Assume `ast` is the root of your AST
python_code = generate_pylse(result)

# Write the generated Python code to the file of the same name as the input but to the current directory
with open(outfile_name, 'w') as f:
    f.write(python_code)

print("----------------------------------")
print(python_code)
print("----------------------------------")
print("Saved generated Python code to", outfile_name)


# ------------------------ END MAIN ------------------------
